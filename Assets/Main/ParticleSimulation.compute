#include "Common.cginc"

int AllParticles_Length;
RWStructuredBuffer<float4> AllParticles_Position;
RWStructuredBuffer<float4> AllParticles_Velocity;
RWStructuredBuffer<float4> AllParticles_Rotation;

int BoundingPlanes_Length;
StructuredBuffer<float4> BoundingPlanes_NormalDistance;


float ParticleRadius;

RWStructuredBuffer<int> HashCodeToSortedParticleIndexes;

RWStructuredBuffer<uint2> SortedParticleIndexes;

bool ClampTo2D;




#pragma kernel BitonicSort_Initialize
[numthreads(64, 1, 1)]
void BitonicSort_Initialize(uint3 id : SV_DispatchThreadID)
{
    SortedParticleIndexes[id.x] = uint2(id.x, GetHashCode(AllParticles_Position[id.x].xyz));
}



uint ComparisonOffset;
uint DirectionChangeStride;

// help from https://github.com/hiroakioishi/UnityGPUBitonicSort/blob/master/GPUBitonicSort/Assets/BitonicSortCS/BitonicSort.compute
// explained at https://en.wikipedia.org/wiki/Bitonic_sorter and https://www.geeksforgeeks.org/bitonic-sort/
#pragma kernel BitonicSort_Sort_Over512
[numthreads(64, 1, 1)]
void BitonicSort_Sort_Over512(uint3 id : SV_DispatchThreadID)
{
    int index0 = id.x & ~ComparisonOffset; // index top
	int index1 = id.x | ComparisonOffset; // index bottom
    if (index1 == id.x) return;
    
    uint hashcode0 = SortedParticleIndexes[index0].y;
    uint hashcode1 = SortedParticleIndexes[index1].y;
    bool shouldSwap = (hashcode0 <= hashcode1) == (bool)(DirectionChangeStride & index0);

    if (shouldSwap)
    {
        uint2 temp = SortedParticleIndexes[index0];
        SortedParticleIndexes[index0] = SortedParticleIndexes[index1];
        SortedParticleIndexes[index1] = temp;
    }
}

#define BITONIC_BLOCK_SIZE 512
groupshared uint2 GroupSharedData[BITONIC_BLOCK_SIZE];
#pragma kernel BitonicSort_Sort_UnderOrEqualTo512
[numthreads(BITONIC_BLOCK_SIZE, 1, 1)]
void BitonicSort_Sort_UnderOrEqualTo512(uint3 Gid  : SV_GroupID, 
				 uint3 DTid : SV_DispatchThreadID, 
				 uint3 GTid : SV_GroupThreadID, 
				 uint  GI   : SV_GroupIndex)
{
	// Load shared data
	GroupSharedData[GI] = SortedParticleIndexes[DTid.x];
	GroupMemoryBarrierWithGroupSync();

	// Sort the shared data
	for (uint comparisonOffset = ComparisonOffset; comparisonOffset > 0; comparisonOffset >>= 1)
	{
		uint2 result = (
            (GroupSharedData[GI & ~comparisonOffset].y <= GroupSharedData[GI | comparisonOffset].y) == (bool)(DirectionChangeStride & DTid.x)) ? 
            GroupSharedData[GI ^ comparisonOffset] : 
            GroupSharedData[GI];
		GroupMemoryBarrierWithGroupSync();
		GroupSharedData[GI] = result;
		GroupMemoryBarrierWithGroupSync();
	}

	// Store shared data
	SortedParticleIndexes[DTid.x] = GroupSharedData[GI];
}



#pragma kernel HashCodeToSortedParticleIndexes_Initialize
[numthreads(64, 1, 1)]
void HashCodeToSortedParticleIndexes_Initialize(uint3 id : SV_DispatchThreadID)
{  
    HashCodeToSortedParticleIndexes[id.x] = -1;
}



// idea from https://developer.download.nvidia.com/assets/cuda/files/particles.pdf
#pragma kernel HashCodeToSortedParticleIndexes_Bin
[numthreads(64, 1, 1)]
void HashCodeToSortedParticleIndexes_Bin(uint3 id : SV_DispatchThreadID)
{  
    uint index1 = id.x + 0;
    uint index2 = id.x + 1;
    if (index2 >= AllParticles_Length) return;

    uint hashcode1 = SortedParticleIndexes[index1].y;
    uint hashcode2 = SortedParticleIndexes[index2].y;

    if (hashcode1 != hashcode2)
    {
        HashCodeToSortedParticleIndexes[hashcode2 * 2 + 0] = index2; // particle start index
        HashCodeToSortedParticleIndexes[hashcode1 * 2 + 1] = index1; // particle end index
    }

    if (index1 == 0) // first particle
        HashCodeToSortedParticleIndexes[hashcode1 * 2 + 0] = index1; // particle start index
    if (index2 == AllParticles_Length - 1) // last particle
        HashCodeToSortedParticleIndexes[hashcode2 * 2 + 1] = index2; // particle end index
}




float3 RayStartWorldPos;
float3 RayDirection;

RWStructuredBuffer<int> HitResults;

float2 RaySphereIntersect(float3 r0, float3 rd, float3 s0, float sr)
{
    float a = dot(rd, rd);
    float3 s0_r0 = r0 - s0;
    float b = 2.0 * dot(rd, s0_r0);
    float c = dot(s0_r0, s0_r0) - (sr * sr);
	float disc = b * b - 4.0 * a * c;
    if (disc < 0.0)
    {
        // no hit
        return float2(-1.0, -1.0);
    }
    else
    {
		return float2(-b - sqrt(disc), -b + sqrt(disc)) / (2.0 * a);
	}
}

#pragma kernel RaycastHitParticles
[numthreads(512, 1, 1)]
void RaycastHitParticles(uint3 id : SV_DispatchThreadID)
{  
    float3 particleWorldPos = AllParticles_Position[id.x].xyz;
    float2 hitResult = RaySphereIntersect(RayStartWorldPos, RayDirection, particleWorldPos, ParticleRadius);
    if (hitResult.x == -1 || hitResult.y == -1) return;

    int originalCount;
    InterlockedAdd(HitResults[0], 1, originalCount);

    HitResults[(originalCount + 1) * 4 + 0] = id.x;
    HitResults[(originalCount + 1) * 4 + 1] = round(particleWorldPos.x * 1000);
    HitResults[(originalCount + 1) * 4 + 2] = round(particleWorldPos.y * 1000);
    HitResults[(originalCount + 1) * 4 + 3] = round(particleWorldPos.z * 1000);
}




float DeltaTime;
int DragParticleIndex;
float3 DragTargetWorldPosition;

#pragma kernel Simulate_AdjustVelocity
[numthreads(64, 1, 1)]
void Simulate_AdjustVelocity(uint3 id : SV_DispatchThreadID)
{
    uint thisParticleIndex = id.x;
    float3 thisParticlePosition = AllParticles_Position[thisParticleIndex].xyz;
    float3 thisParticleVelocity = AllParticles_Velocity[thisParticleIndex].xyz;

    uint hashcodes[27];
    {
        int i = 0;
        for (int x = -1; x <= 1; x++)
            for (int y = -1; y <= 1; y++)
                for (int z = -1; z <= 1; z++)
                {
                    hashcodes[i] = GetHashCode(thisParticlePosition + int3(x,y,z) * VoxelCellEdgeSize);
                    i++;
                }
    }

    float3 thisParticleForce = 0;
    int countOfOtherParticlesInRange = 0;

    for (int h = 0; h < 27; h++)
    {
        uint sortedParticlesStartIndex = HashCodeToSortedParticleIndexes[hashcodes[h] * 2 + 0];
        uint sortedParticlesEndIndex = HashCodeToSortedParticleIndexes[hashcodes[h] * 2 + 1]; 
        if (sortedParticlesEndIndex == -1 || sortedParticlesStartIndex == -1) continue;

        for (uint sortedParticlesIndex = sortedParticlesStartIndex;
            sortedParticlesIndex <= sortedParticlesEndIndex; 
            sortedParticlesIndex++)
        {
            uint otherParticleIndex = SortedParticleIndexes[sortedParticlesIndex].x;
            if (otherParticleIndex != thisParticleIndex)
            {
                float3 otherParticlePosition = AllParticles_Position[otherParticleIndex].xyz;
                float3 direction = thisParticlePosition - otherParticlePosition;
                float len = length(direction);
                const float interactionMaxRadius = 0.2;
                if (len <= interactionMaxRadius)
                {
                    thisParticleForce += direction / len * 30 * (1.0 - min(1.0, len / interactionMaxRadius));
                    countOfOtherParticlesInRange++;
                }
            }
        }
    }

    if (thisParticleIndex == DragParticleIndex)
    {
        float3 direction = DragTargetWorldPosition - thisParticlePosition;
        float len = length(direction);
        thisParticleForce += direction / len * 5;             
    }   
    
 
    for (int index = 0; index < BoundingPlanes_Length; index++)
    {
        float4 plane = BoundingPlanes_NormalDistance[index];
        float distanceToPlane = dot(thisParticlePosition.xyz, plane.xyz) + plane.w - ParticleRadius;
        if (distanceToPlane < 0)
        {
            thisParticleForce += plane.xyz * clamp(abs(distanceToPlane), 0, 1) * 100;

            //thisParticleVelocity = reflect(thisParticleVelocity.xyz, plane.xyz) * 0.8f;
        }
    }
    
    float deltaTime = 0.05f;

    thisParticleForce.y -= 20 * deltaTime;

    thisParticleVelocity += thisParticleForce * deltaTime;


    float damping = (1 - deltaTime * 0.2f);
    thisParticleVelocity *= damping;

    if (ClampTo2D)
        thisParticleVelocity.z = 0;

    AllParticles_Velocity[thisParticleIndex] = float4(thisParticleVelocity, countOfOtherParticlesInRange);
}

#pragma kernel Simulate_AdjustPosition
[numthreads(64, 1, 1)]
void Simulate_AdjustPosition(uint3 id : SV_DispatchThreadID)
{
    uint thisParticleIndex = id.x;
    float3 thisParticlePosition = AllParticles_Position[thisParticleIndex].xyz;

    if (ClampTo2D)
        thisParticlePosition.z = 0;

    AllParticles_Position[thisParticleIndex].xyz = thisParticlePosition + AllParticles_Velocity[thisParticleIndex].xyz * DeltaTime;
}