#include "Common.cginc"

RWStructuredBuffer<float4> AllParticles_Position;
RWStructuredBuffer<float4> AllParticles_Velocity;
int AllParticles_Length;

RWStructuredBuffer<uint> HashCodeToParticles;



uint ComparisonOffset;
uint DirectionChangeStride;

// help from https://github.com/hiroakioishi/UnityGPUBitonicSort/blob/master/GPUBitonicSort/Assets/BitonicSortCS/BitonicSort.compute
// explained at https://en.wikipedia.org/wiki/Bitonic_sorter and  https://www.geeksforgeeks.org/bitonic-sort/
#pragma kernel BitonicSort
[numthreads(64, 1, 1)]
void BitonicSort(uint3 id : SV_DispatchThreadID)
{
    // int index0 = (id.x & (ComparisonOffset-1)) + (id.x & ~(ComparisonOffset-1)) << 1;
	// int index1 = index0 + ComparisonOffset;    
    // int key0 = GetHashCode(AllParticles_Position[index0]);
    // int key1 = GetHashCode(AllParticles_Position[index1]);
    // bool shouldSwap = (key0 <= key1) == (bool)(DirectionChangeStride & index0);

	//uint result = ((shared_data[id.x & ~ComparisonOffset] <= shared_data[id.x | ComparisonOffset]) == (bool)(DirectionChangeStride & id.x)) ? shared_data[id.x ^ ComparisonOffset] : shared_data[id.x];

    int index0 = id.x & ~ComparisonOffset; // index top
	int index1 = id.x | ComparisonOffset; // index bottom
    if (index1 == id.x) return;
    
    uint hashcode0 = GetHashCode(AllParticles_Position[index0].xyz);
    uint hashcode1 = GetHashCode(AllParticles_Position[index1].xyz);
    bool shouldSwap = (hashcode0 <= hashcode1) == (bool)(DirectionChangeStride & index0);

    if (shouldSwap)
    {
        float4 temp = AllParticles_Position[index0];
        AllParticles_Position[index0] = AllParticles_Position[index1];
        AllParticles_Position[index1] = temp;

        temp = AllParticles_Velocity[index0];
        AllParticles_Velocity[index0] = AllParticles_Velocity[index1];
        AllParticles_Velocity[index1] = temp;
    }
}


#pragma kernel HashCodeToParticles_Initialize
[numthreads(64, 1, 1)]
void HashCodeToParticles_Initialize(uint3 id : SV_DispatchThreadID)
{  
    HashCodeToParticles[id.x * 2 + 0] = 0xFFFFFFFF; // max uint
    HashCodeToParticles[id.x * 2 + 1] = 0;
}


#pragma kernel HashCodeToParticles_Bin
[numthreads(64, 1, 1)]
void HashCodeToParticles_Bin(uint3 id : SV_DispatchThreadID)
{  
    uint index = id.x;
    uint hashcode = GetHashCode(AllParticles_Position[index].xyz);

    InterlockedMin(HashCodeToParticles[hashcode * 2 + 0], index); // particle start index
    InterlockedAdd(HashCodeToParticles[hashcode * 2 + 1], 1); // num particles    
}


float DeltaTime;

#pragma kernel Simulate
[numthreads(64, 1, 1)]
void Simulate(uint3 id : SV_DispatchThreadID)
{
    uint thisParticleIndex = id.x;
    float3 thisParticlePosition =  AllParticles_Position[thisParticleIndex].xyz;
    
    uint hashcodes[27];
    {
        int i = 0;
        for (int x = -1; x <= 1; x++)
            for (int y = -1; y <= 1; y++)
                for (int z = -1; z <= 1; z++)
                {
                    hashcodes[i] = GetHashCode(thisParticlePosition + int3(x,y,z) * VoxelCellEdgeSize);
                    i++;
                }
    }

    float3 thisParticleForce = 0;
    int numForceCausingOthers = 0;

    for (int h = 0; h < 27; h++)
    {
        uint cellFirstParticleIndex = HashCodeToParticles[hashcodes[h] * 2 + 0]; 
        uint cellTotalNumParticles = HashCodeToParticles[hashcodes[h] * 2 + 1]; 

        uint otherParticleIndex = cellFirstParticleIndex;
        for (uint p = 0; p < cellTotalNumParticles; p++)
        {
            if (otherParticleIndex != thisParticleIndex)
            {
                float3 otherParticlePosition = AllParticles_Position[otherParticleIndex].xyz;
                float3 d = thisParticlePosition - otherParticlePosition;
                float l = length(d);
                const float interactionMaxRadius = 0.2;
                if (l <= interactionMaxRadius)
                {
                    thisParticleForce += d / l * 10 * (1.0 - min(1.0, l / interactionMaxRadius));
                    numForceCausingOthers++;
                }
            }
            otherParticleIndex++;
        }
    }

    float3 thisParticleVelocity = AllParticles_Velocity[thisParticleIndex].xyz;
    
    thisParticleVelocity.z = 0;    
    thisParticlePosition.z = 0;

    thisParticleVelocity += thisParticleForce * DeltaTime;
    AllParticles_Position[thisParticleIndex] = float4(thisParticlePosition + thisParticleVelocity * DeltaTime, numForceCausingOthers);
    AllParticles_Velocity[thisParticleIndex].xyz = thisParticleVelocity * 0.99;
}